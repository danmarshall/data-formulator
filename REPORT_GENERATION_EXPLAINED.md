# Report Generation and Share Image Functionality

This document explains how Reports are created in Data Formulator and how the Share Image button works.

## How Reports are Created

### Quick Answer

**Reports are Markdown documents generated by an AI/LLM agent** (not HTML). The LLM receives chart images, data summaries, and style preferences, then generates Markdown content that is rendered in the frontend.

### Format: Markdown Generated by LLM

Reports in Data Formulator are **Markdown documents generated by an AI/LLM agent** (not HTML). The system uses a sophisticated multi-stage process:

```
┌─────────────┐      ┌──────────────┐      ┌─────────────┐
│  Frontend   │ ───> │   Backend    │ ───> │  Frontend   │
│  (Browser)  │      │  (Python)    │      │  (Browser)  │
└─────────────┘      └──────────────┘      └─────────────┘
     │                     │                      │
     │ 1. Charts          │ 3. Markdown          │ 5. Rendered
     │    + Data          │    (streaming)       │    Report
     │    + Style         │                      │
     │                    │                      │
     │ 2. PNG Images      │ 4. LLM               │
     │    (base64)        │    Generates         │
     └───────────────────>│    Content           │
                          └─────────────────────>│
```

### The Report Generation Pipeline

#### 1. **Frontend: Chart Selection and Submission** (`src/views/ReportView.tsx`)

When a user wants to create a report:
- Users select charts from the UI (lines 227-486)
- They choose a report style: "short note", "blog post", "social post", or "executive summary" (lines 832-850)
- The system captures high-resolution chart images in PNG format using Vega (lines 488-590)

#### 2. **Image Processing** (Frontend to Backend)

Charts are converted to images through this process:
- **SVG Generation**: Charts are rendered as SVG using Vega-Embed (lines 517-523)
- **PNG Conversion**: SVG is converted to PNG via HTML Canvas (lines 539-575)
- **Data URL Creation**: PNG images are encoded as base64 data URLs (line 557)
- **Transmission**: These data URLs are sent to the backend in the API request (line 646)

#### 3. **Backend: LLM Report Generation** (`py-src/data_formulator/agents/agent_report_gen.py`)

The backend receives:
```python
{
  "input_tables": [...],      # Original data tables
  "charts": [
    {
      "chart_id": "...",        # Unique chart identifier
      "code": "...",            # Python/SQL code that generated the chart
      "chart_data": {...},      # The processed data
      "chart_url": "data:image/png;base64,..." # Base64 encoded PNG
    }
  ],
  "style": "blog post"        # Report style
}
```

The `ReportGenAgent` class:
- Takes chart images (as base64 data URLs), data summaries, and style preferences
- Sends them to the LLM via a multimodal prompt (lines 117-130)
- The LLM sees:
  - Data summaries for each chart
  - The actual chart images (high resolution)
  - Code that generated each chart
  - Style instructions

#### 4. **LLM Instructions** (System Prompt - lines 14-52)

The LLM is instructed to:
- Act as a journalist generating a blog post
- Output **pure Markdown** format
- Include chart placeholders in the format: `[IMAGE(chart_id)]`
- Write in the specified style:
  - **"short note"**: 300 characters max, 3 sentences
  - **"blog post"**: 1 minute reading time (~200 words)
  - **"social post"**: Short form, social media style
  - **"executive summary"**: Formal, detailed with bullet points

Key Markdown elements used:
- `# Title` for headings
- Paragraphs for content
- `[IMAGE(chart_id)]` placeholders for charts
- Bullet points, bold, italics, code blocks, tables as needed
- Summary paragraph starting with "**In summary**"

#### 5. **Streaming Response** (`agent_routes.py` lines 688-730)

- The backend streams the Markdown content back to the frontend chunk by chunk
- This allows real-time display as the LLM generates the report (lines 678-710 in ReportView.tsx)
- Image placeholders `[IMAGE(chart_id)]` are replaced with actual `<img>` tags on the frontend (lines 321-333)

#### 6. **Frontend: Markdown Rendering** (`ReportView.tsx` lines 1192-1198)

The Markdown is rendered using the `MuiMarkdown` component with custom style overrides:
- **Notion-style** for blog posts (lines 101-151)
- **Social post style** for social media (lines 154-171)
- **Executive summary style** for formal reports (lines 174-211)

Each style has custom typography, spacing, colors, and layout rules that transform the Markdown into beautifully formatted reports.

---

## How the Share Image Button Works

### Quick Answer

**The PNG is rendered on the FRONTEND** (in the browser), not the backend. It uses the `html2canvas` library to capture the displayed report as an image and copies it to the clipboard.

### Image Generation: Frontend Rendering (NOT Backend)

The Share Image button creates a PNG screenshot **entirely on the frontend** using the browser. Here's how:

```
┌─────────────────────────────────────────────────┐
│           Frontend (Browser)                     │
│                                                  │
│  1. Report HTML/CSS  ──> 2. html2canvas         │
│     (rendered)            captures DOM           │
│                                                  │
│  3. Canvas Element   ──> 4. Convert to PNG      │
│                                                  │
│  5. Clipboard API    ──> User can paste image   │
│                           anywhere!              │
└─────────────────────────────────────────────────┘

No backend involvement - all done in the browser!
```

### The Share Image Process

#### 1. **Trigger** (Line 262 in `ReportView.tsx`)

When user clicks "Share Image" button (lines 1114-1143):
```tsx
<Button onClick={shareReportAsImage}>Share Image</Button>
```

#### 2. **HTML to Canvas Conversion** (Lines 262-316)

The `shareReportAsImage` function:

```typescript
const shareReportAsImage = async () => {
  // Find the report content element
  const reportElement = document.querySelector('[data-report-content]');
  
  // Use html2canvas library to convert HTML to canvas
  const canvas = await html2canvas(reportElement, {
    backgroundColor: '#ffffff',
    scale: 2,              // 2x resolution for quality
    useCORS: true,         // Handle cross-origin images
    scrollX: 0,
    scrollY: 0,
    width: reportElement.scrollWidth + 4,
    height: reportElement.scrollHeight + 4
  });
  
  // Convert canvas to PNG blob
  canvas.toBlob((blob) => {
    // Copy to clipboard
    navigator.clipboard.write([
      new ClipboardItem({ 'image/png': blob })
    ]);
  }, 'image/png', 0.95);
}
```

#### 3. **Technology: html2canvas Library**

- **Library**: [html2canvas](https://html2canvas.hertzen.com/) (imported line 38)
- **What it does**: Captures a screenshot of DOM elements by rendering them to an HTML Canvas
- **Process**:
  1. Traverses the DOM tree of the report element
  2. Reads computed styles, text, and embedded images
  3. Redraws everything onto a Canvas element
  4. Canvas is converted to PNG blob

#### 4. **Clipboard API** (Lines 295-309)

The PNG image is copied to the clipboard using the modern Clipboard API:
```typescript
navigator.clipboard.write([
  new ClipboardItem({ 'image/png': blob })
])
```

- This allows users to paste the image anywhere (Slack, email, documents, etc.)
- Success feedback is shown with a green checkmark and "Copied!" message (lines 1119-1141)

#### 5. **Why Frontend Rendering?**

The image is rendered on the **frontend** (not backend) because:

1. **Already Rendered**: The report is already displayed in the browser with all styles applied
2. **No Server Round-trip**: Faster - no need to send data to server and wait
3. **Full Fidelity**: Captures exactly what the user sees, including fonts, colors, spacing
4. **Browser Capabilities**: Modern browsers excel at rendering HTML/CSS
5. **No Server Load**: Reduces backend processing requirements

---

## Summary

### Report Generation
- **Format**: Markdown (not HTML)
- **Generation**: AI/LLM creates the content based on chart images, data, and style preferences
- **Rendering**: Frontend converts Markdown to styled HTML using MuiMarkdown
- **Charts**: Embedded as PNG images (converted from Vega SVG)

### Share Image Button  
- **Rendering Location**: Frontend (browser)
- **Technology**: html2canvas library
- **Process**: Captures rendered HTML → Canvas → PNG → Clipboard
- **Output**: High-resolution PNG image copied to clipboard

Both systems are designed for performance, quality, and user experience - reports are streamed in real-time, and image sharing is instant without server involvement.
